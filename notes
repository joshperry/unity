server						client
------						------
[accept]			<--		connect
challenge			-->		[encrypt]
[verify]			<--		response (encrypted challenge, client name)
hangup if invalid
query info			-->		
					<--		info (size)

---
use automake

order includes according to source directory
fix function definitions
  return type on first line
  function name in 1st column on 2nd line
  parameters at 1st tab stop starting 3rd line, one per line
fix parameter indentation
  in header file: 7th tab stop (not 8th)
  in source file: 1st tab stop (not 8th)

---
HTTP stuff
  no way to save config using HTTP
    should have a button or a page to force save of config
    or just save config every time it's changed
  should use authentication (at least basic)
  provide way to kill/restart server via HTTP
  provide way to query why locked to screen?
    handy for debugging at least

---
CThreadRep::threadSignalHandler not shutdown on assert
  thread stays around and holds our resources (like sockets)
  should ensure that it terminates correctly

---
win32:
  provide taskbar icon

win32 dll:
  should make this as small as possible
    don't use standard libraries
    use custom _DllMainCRTStartup();  just call DllMain() from it.
    use /MERGE linker switch to merge sections

clean up c:\winnt\synergy.sgc

desktop switcher program failure when running synergy as service
  returns access denied from CreateDesktop()
  don't know why

client will need to be able to retry connecting to server
  in case server isn't ready yet, client can camp

---
bug with half-duplex keys
  win32 server sent num-lock to grace
  grace converts to half-duplex so only synthesizes key down
  now grace starts server and is locked to screen
  grace should ignore half duplex keys when seeing if locked to screen

---
must send up key events when leaving screen for keys still down
  some key combos get eaten and the key ups aren't sent
  e.g. ctrl+alt+del on win2k to grace
    mouse is forced back to to win2k
    ctrl and alt up not sent to grace
    grace thinks ctrl and alt are down 'til user physically press/releases them

---
CClient and CServer:
  not checking in stop() that we're actually running
  must mutex m_primary/m_screen
    they could be NULL if in the middle of shutting down

---
win32 screen saver
  win95 etc:
    keybd_event can terminate screen saver but not mouse_event
    keybd_event resets screen saver start timer but not mouse_event
    to kill screen saver (if it's known to be running):
		PostMessage (GetActiveWindow(), WM_CLOSE, 0, 0L);
    to find if screen saver is running:
		FindWindow ("WindowsScreenSaverClass", NULL);
  win nt 4:
    mouse_event resets screen saver start timer but not keybd_event
    neither can stop screen saver because it runs in a separate desktop
    to kill screen saver:
		BOOL CALLBACK KillScreenSaverFunc(HWND hwnd, LPARAM lParam)
		{
		  if(IsWindowVisible(hwnd))
			  PostMessage(hwnd, WM_CLOSE, 0, 0);
		  return TRUE;
		}

		HDESK hdesk;

		hdesk = OpenDesktop(TEXT("Screen-saver"),
						   0,
						   FALSE,
						   DESKTOP_READOBJECTS | DESKTOP_WRITEOBJECTS);
		if (hdesk)
		{
		  EnumDesktopWindows(hdesk, KillScreenSaverFunc, 0);
		  CloseDesktop(hdesk);
		}

---
unix:
  restarting fails to connect until a user logs in:
    Xlib: no protocol specified
    this is caused by login manager
      all clients are rejected, except those started by manager itself
    workaround is to have synergy started by login manager
      should then use --no-restart, though that's not necessary
    affects client and server
  cannot switch screens on login screen:
    xdm,kdm grab keyboard for duration of login screen
    synergy cannot switch unless it can grab keyboard
    gdm doesn't appear to grab keyboard or mouse for duration
    affects server, only
  check if DISPLAY env var is unset.  use ":0.0" as default.

---
bug in updating screens
  saw a goofy set of screens after update
  i think the config was similar to:
    A B
    C
    D E

---
not handling international characters

---
not handling screen saver at all yet

---
not distinguishing between caps lock and shift lock
  In Caps Lock mode, the alphabetic keys send their uppercase (shifted) char-
  acter when pressed alone. For Caps Lock mode, pressing and releasing the
  lock key turns on the mode and pressing and releasing the lock key again
  turns off the mode. In Shift Lock mode, all keys on the main keypad send
  their shifted character when pressed alone. For Shift Lock mode, pressing
  and releasing the Lock key turns on the mode, and pressing and releasing
  either the Lock or the Shift key turns off the mode.

---
currently sending all clipboards to all clients
  some clients may not need all clipboards
  add filtering mechanism

---
sometimes not sending correct clipboard
  some kind of race condition i think
  can select text then switch and get empty clipboard
    switching back to owner screen then out gets correct clipboard
  dunno if this is still a problem

---
win32 not sending correct clipboard
  got 43 bytes sent for a 3 byte selection
  remaining bytes were 0
  problem persisted;  also got 43 bytes for a 2 byte selection

---
need timeout on CXWindowsClipboard::CReply objects
  should flush replies that are too old
  assumption is that requestor is broken

---
inconsistencies
  exceptions
    using getWhat() in some places to return a code, elsewhere returns message
  references/pointers
    should use pointers for any in/out parameter
      but using references in some places

---
win32 hook DLL sometimes not unloaded when server is killed?
  will get assertion on restart as if DLL was still loaded.
  can tell because all DLL copies share data segment.
  should prevent multiple copies from loading (or initializing)
    replace asserts with (multithread locked) check of variables
    return 0 if busy
    server must handle failure
  try to figure out why it's not unloading

---
test:
  X primary
    ctrl+alt+keypad_add, ctrl+alt_keypad_minus -> eaten by primary X server
    ctrl+alt+backspace probably eaten by primary X server if so configured
    ctrl+alt+delete probably eaten locally
      probably underneath primary X server too
  Win32 desktop -> X laptop
    eaten global hot keys:
      ctrl+alt+delete -> task manager (or logon or reboot)
      alt+[shift+]tab -> cycle through tasks
      alt+[shift+]esc -> cycle windows
      ctrl+esc -> start menu
      windows+R -> run dialog
      windows+M -> minimize all
      windows+shift+M -> undo minimize all
      windows+F1 -> help
      windows+E -> explorer
      windows+F -> find files
      windows+ctrl+F -> find computer
      windows+tab -> cycle through taskbar buttons
      windows+break -> system properties
    not eaten:
      alt+space -> system menu
      shift+F10 -> context menu
      app key -> context menu
    misc:
      accessibility shortcuts: not eaten but dialogs appear anyway
  X laptop -> Win32 desktop
    check:
      shift+tab -> okay
      alt+[shift+]tab -> okay
      alt+[shift+]esc -> okay
      ctrl+esc -> start menu -> okay
      ctrl+esc, esc, shift+F10 -> toolbar context menu -> okay
      F10 -> activate menu in explorer -> okay
      shift+F10 -> context menu -> okay
      alt+space -> context menu -> okay
      alt+hyphen -> MDI window menu -> okay
      alt+letter -> open corresponding menu -> okay
      alt+F6 -> switch between windows in single program -> okay
      shift+insert CD-ROM -> bypass auto-run
    check accessibility shortcuts -> does not work
    check accessibility features
      sticky keys -> no
      filter keys -> no
      toggle keys -> no
      mouse keys -> no
      high contrast -> no
  X desktop -> win32
    check:
      shift+tab
      windows+R -> run dialog
      windows+M -> minimize all
      windows+shift+M -> minimize all
      windows+F1 -> help
      windows+E -> explorer
      windows+F -> find files
      windows+ctrl+F -> find computer
      windows+tab -> cycle through taskbar buttons
      windows+break -> system properties
      app key -> context menu
  Win32 -> Win32
    alt+F6 -> eaten (isabel to audrey, but not audrey to isabel)
    check accessibility shortcuts work on secondary
    check accessibility features work on secondary

---
avoid fullscreen transparent window on win32
  using CBT hook to discard activation/focus messages
    but it's not being called when we lose keyboard input
  also, we sometimes don't get the keyboard input to start with

---
keyboard hook problems (win32)
  now passing keyboard events through in most cases
    this fixes problem on isabel where toggle lights don't toggle
    and num-lock behaved incorrectly (generated wrong keys).
    seems the DefWindowProc() needed to process the keys
  unfortunately, keys sometimes leak into wrong app.  seems related
    to times when we don't get the keyboard input.  key events are
    not delivered to app on primary until cursor returns to primary.
    no idea how that's possible.
  current have some code to check active window and reset it in
    keyboard hook.  that code doesn't work.
  seem to be having problems with windows key now, too.  looks like
    a down is sent but not the corresponding up so secondary system
    thinks the key is always down.

---
try to determine keyboard quirks automatically
  in particular, set the half-duplex flags
  maybe KBD extension will help determine this

---
key events sent to console on win me (95/98?) are very slow
  1/4 to 1/2 second delay before key up is processed
  key up log message is also delayed
    console causing a system-wide delay?

---
adjust thread priorities on win32
  maybe remove changes altogether
  currently isabel starts single-stepping mouse when dragging window
    sometimes it goes normal speed but it's mostly very slow
    even a very high priority doesn't seem to help
      haven't tried real-time priority
  a very high priority on client fixes delay when typeing into console
  is it the output console causing the slowness?

---
Accessibility Shortcuts

   Key                                Result
   -------------------------------------------------------------------
   Tap SHIFT 5 times                  Toggles StickyKeys on and off.

   Press down and hold the right      Toggles FilterKeys on and off.
   SHIFT key for 8 seconds

   Press down and hold the NUM LOCK   Toggles ToggleKeys on and off.
   key for 5 seconds

   Left ALT+left SHIFT+NUM LOCK       Toggles MouseKeys on and off.

   Left ALT+left SHIFT+PRINT SCREEN   Toggles High Contrast on and off.

---
disable ctrl+alt+del info:
  SystemParametersInfo(SPI_SETSCREENSAVERRUNNING, TRUE, &dummy, 0)
    fools system into thinking screen saver is running
    that disables ctrl+alt+del, alt+tab, ctrl+esc
    dunno if keystrokes are queued
    may be limited to win 95/98/me
  win nt sp 3 and above:
    low-level keyboard hook is called before ctrl+esc, alt+tab, alt+esc
    use that to capture and disable
    seems that low-level hook is notified of ctrl+alt+del but can't stop it
  win nt sp 2 and below
    ctrl+esc can be disabled by replacing task manager (dunno how)
    RegisterHotKey() can be used to catch alt+tab and alt+esc
      only while app is running, of course
  win nt
    keyboard filter driver can capture keys (see win NT DDK)
  http://216.239.51.100/search?q=cache:q-f03UHhFMMC:www.thescarms.com/VBasic/StopReBoot.asp+alt%2Btab+disable&hl=en
    some info on changing keyboard scan code mapping
    can be used to disable keys but looks like reboot is required

---
Q179905
  suggestion for bypassing hook code when called by debugger.
  may prevent system from getting locked up when debugging.

---
how is CTCPSocket::connect() able to cancel?
  looks like it can't
  make it asynchronous and use poll() to wait for connection
    use testCancel() to make it cancellable

---
win32 rel notes:
  HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Windows\NoInteractiveServices
    can prevent an interactive service from running interactively.
    how can we tell if we're not running interactively?
    even if not interactive we can use MessageBox() to alert user
      use MB_SERVICE_NOTIFICATION flag
      must use a separate thread in initialization if called from handler
      must close dialog if CTRL_LOGOFF_EVENT is received
        see SetConsoleCtrlHandler() and CLog (which uses it)
    maybe possible to get around NoInteractiveServices
      modify DACLs on windows station/desktops to impersonate logged on user
      see "Interacting with the User by a Win32 Service"
